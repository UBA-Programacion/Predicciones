<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Laboratorio de Machine Learning No Supervisado</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet" />
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
  <style>
    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: "Inter", sans-serif;
    }

    .card {
      background-color: #1a1a1a;
      border: 1px solid #333;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
    }

    .btn {
      transition: all 0.2s;
    }

    .btn:hover {
      transform: scale(1.05);
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #f97316;
      cursor: pointer;
      border-radius: 50%;
    }

    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #f97316;
      cursor: pointer;
      border-radius: 50%;
    }

    .chart-container {
      position: relative;
      height: 400px;
    }

    /* Gemini Modal Styles */
    .modal-backdrop {
      background-color: rgba(0, 0, 0, 0.7);
    }

    .modal-content {
      background-color: #1e1e1e;
    }

    .loader {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #f97316;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body class="bg-black text-gray-200">
  <nav class="bg-gray-900/50 backdrop-blur-sm border-b border-gray-700 sticky top-0 z-50">
    <div class="container mx-auto px-4 sm:px-6 lg:px-8">
      <div class="flex items-center justify-between h-16">
        <div class="flex items-center">
          <div class="flex-shrink-0">
            <span class="text-white font-bold text-xl">Predicciones<span class="text-orange-500">.AI</span></span>
          </div>
        </div>
        <div class="hidden md:block">
          <div class="ml-10 flex items-baseline space-x-4">
            <a href="index.html#laboratorios"
              class="text-gray-300 hover:text-orange-400 px-3 py-2 rounded-md text-sm font-medium">Laboratorios</a>
            <a href="index.html#nosotros"
              class="text-gray-300 hover:text-orange-400 px-3 py-2 rounded-md text-sm font-medium">Nosotros</a>
            <a href="index.html#contacto"
              class="text-gray-300 hover:text-orange-400 px-3 py-2 rounded-md text-sm font-medium">Contacto</a>
          </div>
        </div>
        <div class="-mr-2 flex md:hidden">
          <button type="button" id="mobile-menu-button"
            class="bg-gray-800 inline-flex items-center justify-center p-2 rounded-md text-gray-400 hover:text-white hover:bg-gray-700 focus:outline-none"
            aria-controls="mobile-menu" aria-expanded="false">
            <span class="sr-only">Abrir men√∫</span>
            <svg id="hamburger-icon" class="block h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none"
              viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
            </svg>
            <svg id="close-icon" class="hidden h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none"
              viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
      </div>
    </div>
    <div class="md:hidden hidden" id="mobile-menu">
      <div class="px-2 pt-2 pb-3 space-y-1 sm:px-3">
        <a href="index.html#laboratorios"
          class="text-gray-300 hover:bg-gray-700 hover:text-white block px-3 py-2 rounded-md text-base font-medium">Laboratorios</a>
        <a href="index.html#nosotros"
          class="text-gray-300 hover:bg-gray-700 hover:text-white block px-3 py-2 rounded-md text-base font-medium">Nosotros</a>
        <a href="index.html#contacto"
          class="text-gray-300 hover:bg-gray-700 hover:text-white block px-3 py-2 rounded-md text-base font-medium">Contacto</a>
      </div>
    </div>
  </nav>

  <div class="container mx-auto p-4 md:p-8">
    <header class="text-center my-12">
      <h1 class="text-4xl md:text-6xl font-black text-white">
        Laboratorio de <span class="text-orange-500">ML No Supervisado</span>
      </h1>
      <p class="text-gray-400 mt-4 max-w-2xl mx-auto">
        Ac√° soltamos a los algoritmos en un quilombo de datos sin etiquetas y
        les pedimos que encuentren orden. Son los detectives del Machine
        Learning.
      </p>
    </header>

    <main class="space-y-16">
      <section id="clustering">
        <div class="flex justify-between items-start mb-8">
          <h2 class="text-3xl font-bold border-b-2 border-orange-500 pb-2">
            üï∫üíÉ 1. Clustering (K-Means)
          </h2>
          <button class="btn gemini-btn bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-4 rounded-lg"
            data-model="Clustering (K-Means)">
            ‚ú® Explic√°melo, Gemini
          </button>
        </div>
        <div class="card rounded-lg p-6">
          <p class="text-gray-400 mb-4"><b>Analog√≠a:</b> Imaginate que el algoritmo es un patovica en un boliche. No
            conoce a nadie, pero le dec√≠s "che, armame 3 grupitos". El tipo empieza a mirar y junta a los que est√°n m√°s
            cerca entre s√≠. Al final, ten√©s a los cumbieros por un lado, los rolingas por otro y los chetos en el VIP,
            todo sin que nadie le diga qui√©n era qui√©n.</p>
          <div class="bg-gray-900 p-4 rounded-lg mb-6">
            <p class="font-mono text-center text-sm text-orange-400">Objetivo: Minimizar `$$ \sum_{i=1}^{k} \sum_{x \in
              S_i} ||x - \mu_i||^2 $$`</p>
            <ul class="text-xs mt-2 space-y-1 text-gray-300">
              <li><span class="font-bold text-white">k:</span> La cantidad de grupos (clusters) que quer√©s encontrar. Es
                la √∫nica variable que le ten√©s que decir vos.</li>
              <li><span class="font-bold text-white">S·µ¢:</span> Cada uno de los 'k' grupos encontrados.</li>
              <li><span class="font-bold text-white">Œº·µ¢:</span> El centro de cada grupo (el "l√≠der" del grupito).</li>
              <li><span class="font-bold text-white">En criollo:</span> La f√≥rmula busca que la distancia de cada
                persona al centro de su grupito sea la menor posible.</li>
            </ul>
          </div>
          <div class="flex items-center space-x-4 mb-6">
            <label for="clustersSlider" class="font-medium">Cantidad de Grupos (k):
              <span id="clustersValue" class="font-bold text-orange-400">3</span></label>
            <input id="clustersSlider" type="range" min="2" max="8" value="3"
              class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer" />
            <button id="clusterBtn"
              class="btn bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-4 rounded-lg whitespace-nowrap">
              Organizar Boliche
            </button>
          </div>
          <div class="chart-container">
            <canvas id="clusteringChart"></canvas>
          </div>
        </div>
      </section>

      <section id="dimension-reduction">
        <div class="flex justify-between items-start mb-8">
          <h2 class="text-3xl font-bold border-b-2 border-orange-500 pb-2">
            üìù 2. Reducci√≥n de Dimensionalidad
          </h2>
          <button class="btn gemini-btn bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-4 rounded-lg"
            data-model="Reducci√≥n de Dimensionalidad (PCA y t-SNE)">
            ‚ú® Explic√°melo, Gemini
          </button>
        </div>
        <div class="card rounded-lg p-6">
          <p class="text-gray-400 mb-6"><b>Analog√≠a General:</b> Ten√©s una foto 3D s√∫per compleja. Estos modelos son
            como aplastarla para poder verla en una hoja de papel (2D) sin que se haga un manch√≥n inentendible. Te
            resumen el bardo.</p>
          <div class="text-center mb-8">
            <button id="dimRedBtn"
              class="btn bg-orange-600 hover:bg-orange-700 text-white font-bold py-3 px-6 rounded-lg">
              Generar y Resumir Nuevos Datos
            </button>
          </div>
          <div class="grid lg:grid-cols-2 gap-8">
            <div>
              <h4 class="text-xl font-bold text-center mb-2">
                PCA (El L√≥gico)
              </h4>
              <p class="text-sm text-gray-400 text-center mb-4"><b>Analog√≠a Espec√≠fica:</b> PCA es como un director de
                c√°maras en un partido. En lugar de mostrarte a los 22 jugadores a la vez, se enfoca en la direcci√≥n
                principal del juego (la m√°xima "varianza"). Te muestra el resumen de las jugadas m√°s importantes,
                manteniendo la estructura general del partido.</p>
              <div class="bg-gray-900 p-4 rounded-lg mb-6">
                <p class="font-mono text-center text-sm text-orange-400">Objetivo: Encontrar los componentes principales
                  (vectores propios) que maximizan la varianza.</p>
                <ul class="text-xs mt-2 space-y-1 text-gray-300">
                  <li><span class="font-bold text-white">Variables Clave:</span> No tiene perillas para tocar. El
                    algoritmo solo encuentra las "mejores" proyecciones de los datos para resumirlos.</li>
                </ul>
              </div>
              <div class="chart-container">
                <canvas id="pcaChart"></canvas>
              </div>
            </div>
            <div>
              <h4 class="text-xl font-bold text-center mb-2">
                t-SNE (El Soci√≥logo)
              </h4>
              <p class="text-sm text-gray-400 text-center mb-4"><b>Analog√≠a Espec√≠fica:</b> t-SNE es el organizador de
                fiestas. No le importa tanto la estructura general, sino que los "grupitos de amigos" que estaban juntos
                en la fiesta original (en muchas dimensiones) sigan juntos en la foto final (en 2D). Es el campe√≥n para
                que los clusters se vean bien separados.</p>
              <div class="bg-gray-900 p-4 rounded-lg mb-6">
                <p class="font-mono text-center text-sm text-orange-400">Objetivo: Minimizar la divergencia de
                  Kullback-Leibler entre las distribuciones de probabilidad de los pares de puntos.</p>
                <ul class="text-xs mt-2 space-y-1 text-gray-300">
                  <li><span class="font-bold text-white">Variables Clave:</span> Al igual que PCA, es un algoritmo que
                    trabaja solo. Su magia est√° en c√≥mo decide qu√© puntos son "vecinos" y c√≥mo los representa en el
                    gr√°fico final.</li>
                </ul>
              </div>
              <div class="chart-container">
                <canvas id="tsneChart"></canvas>
              </div>
            </div>
          </div>
        </div>
      </section>
    </main>

    <footer class="text-center mt-16 text-gray-500">
      <p>Hecho con üßâ y ciencia de datos. Laboratorio de Predicciones.</p>
    </footer>
  </div>

  <!-- Gemini Modal -->
  <div id="gemini-modal" class="hidden fixed inset-0 z-50 overflow-y-auto" aria-labelledby="modal-title" role="dialog"
    aria-modal="true">
    <div class="flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0">
      <div class="fixed inset-0 modal-backdrop" aria-hidden="true"></div>
      <span class="hidden sm:inline-block sm:align-middle sm:h-screen" aria-hidden="true">&#8203;</span>
      <div
        class="inline-block align-bottom rounded-lg text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg sm:w-full modal-content border border-orange-500/50">
        <div class="px-4 pt-5 pb-4 sm:p-6 sm:pb-4">
          <div class="sm:flex sm:items-start">
            <div
              class="mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-orange-600 sm:mx-0 sm:h-10 sm:w-10">
              ‚ú®
            </div>
            <div class="mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left w-full">
              <h3 class="text-lg leading-6 font-medium text-white" id="modal-title">
                Explicaci√≥n de Gemini
              </h3>
              <div class="mt-4 border-b border-gray-700 pb-4">
                <label for="gemini-api-key-input" class="block text-sm font-medium text-gray-400">Tu Clave de API de
                  Gemini</label>
                <input type="password" id="gemini-api-key-input"
                  class="mt-1 block w-full bg-gray-900 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-orange-500 focus:border-orange-500 sm:text-sm"
                  placeholder="Peg√° tu clave ac√°..." />
                <p class="mt-1 text-xs text-gray-500">
                  Consegu√≠ una clave gratis en
                  <a href="https://aistudio.google.com/app/apikey" target="_blank"
                    class="text-orange-400 hover:underline">Google AI Studio</a>.
                </p>
              </div>
              <p class="text-sm text-gray-400 my-4" id="modal-subtitle">
                P√≠dele a la IA que te explique este modelo.
              </p>
              <div class="my-4 space-x-2">
                <button class="prompt-btn btn bg-gray-700 hover:bg-orange-600 text-xs py-1 px-3 rounded-full"
                  data-style="simple">
                  Explicaci√≥n Simple
                </button>
                <button class="prompt-btn btn bg-gray-700 hover:bg-orange-600 text-xs py-1 px-3 rounded-full"
                  data-style="analogy">
                  Analog√≠a Creativa
                </button>
                <button class="prompt-btn btn bg-gray-700 hover:bg-orange-600 text-xs py-1 px-3 rounded-full"
                  data-style="business">
                  Para Negocios
                </button>
              </div>
              <div id="gemini-response-container"
                class="mt-4 p-3 bg-black/50 rounded-md min-h-[150px] max-h-[300px] overflow-y-auto">
                <div id="gemini-loader" class="hidden flex justify-center items-center h-full">
                  <div class="loader"></div>
                </div>
                <p id="gemini-response" class="text-gray-300"></p>
              </div>
            </div>
          </div>
        </div>
        <div class="px-4 py-3 sm:px-6 sm:flex sm:flex-row-reverse">
          <button id="close-modal-btn" type="button"
            class="mt-3 w-full inline-flex justify-center rounded-md border border-gray-600 shadow-sm px-4 py-2 bg-gray-800 text-base font-medium text-white hover:bg-gray-700 sm:mt-0 sm:ml-3 sm:w-auto sm:text-sm">
            Cerrar
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // --- L√ìGICA PARA EL MEN√ö RESPONSIVO ---
    const mobileMenuButton = document.getElementById("mobile-menu-button");
    const mobileMenu = document.getElementById("mobile-menu");
    const hamburgerIcon = document.getElementById("hamburger-icon");
    const closeIcon = document.getElementById("close-icon");
    mobileMenuButton.addEventListener("click", () => {
      mobileMenu.classList.toggle("hidden");
      hamburgerIcon.classList.toggle("hidden");
      closeIcon.classList.toggle("hidden");
    });

    // --- CHART DEFAULTS ---
    const mlChartOptions = {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          type: "linear",
          position: "bottom",
          title: {
            display: true,
            text: "Caracter√≠stica 1",
            color: "#9ca3af",
          },
          grid: { color: "rgba(255,255,255,0.1)" },
          ticks: { color: "#9ca3af" },
        },
        y: {
          title: {
            display: true,
            text: "Caracter√≠stica 2",
            color: "#9ca3af",
          },
          grid: { color: "rgba(255,255,255,0.1)" },
          ticks: { color: "#9ca3af" },
        },
      },
      plugins: {
        legend: {
          labels: { color: "#9ca3af" }
        }
      },
    };
    const colors = ["#f97316", "#34d399", "#60a5fa", "#f472b6", "#fbbf24", "#a78bfa", "#ef4444", "#22d3ee"];

    // --- CLUSTERING (K-MEANS) ---
    const clustersSlider = document.getElementById("clustersSlider");
    const clustersValue = document.getElementById("clustersValue");
    const clusterBtn = document.getElementById("clusterBtn");
    const clusteringChartCtx = document.getElementById("clusteringChart").getContext("2d");
    let clusteringChart;
    let clusterData;

    function generateClusterData(numPoints = 150, numClusters = 5) {
      const data = [];
      const realCentroids = Array.from({ length: numClusters }, () => ({
        x: Math.random() * 10,
        y: Math.random() * 10,
      }));
      for (let i = 0; i < numPoints; i++) {
        const centroidIndex = Math.floor(Math.random() * numClusters);
        const centroid = realCentroids[centroidIndex];
        data.push({
          x: centroid.x + (Math.random() - 0.5) * 3,
          y: centroid.y + (Math.random() - 0.5) * 3,
        });
      }
      return data;
    }

    function kMeans(data, k) {
      let centroids = data.slice(0, k).map((p) => ({ ...p }));
      let assignments = [];
      let changed = true;
      for (let iter = 0; iter < 20 && changed; iter++) {
        changed = false;
        assignments = data.map((point) => {
          let minDist = Infinity;
          let bestCentroid = 0;
          centroids.forEach((centroid, i) => {
            const dist = Math.hypot(
              point.x - centroid.x,
              point.y - centroid.y
            );
            if (dist < minDist) {
              minDist = dist;
              bestCentroid = i;
            }
          });
          return bestCentroid;
        });
        const newCentroids = Array.from({ length: k }, () => ({
          x: 0,
          y: 0,
          count: 0,
        }));
        data.forEach((point, i) => {
          const assignment = assignments[i];
          newCentroids[assignment].x += point.x;
          newCentroids[assignment].y += point.y;
          newCentroids[assignment].count++;
        });
        const updatedCentroids = newCentroids.map((c, i) =>
          c.count === 0
            ? centroids[i]
            : { x: c.x / c.count, y: c.y / c.count }
        );
        for (let i = 0; i < k; i++) {
          if (
            centroids[i].x !== updatedCentroids[i].x ||
            centroids[i].y !== updatedCentroids[i].y
          ) {
            changed = true;
            break;
          }
        }
        centroids = updatedCentroids;
      }
      return assignments;
    }

    function drawClusteringChart(data, assignments = null) {
      if (clusteringChart) clusteringChart.destroy();
      const datasets = [];
      if (assignments) {
        const k = parseInt(clustersSlider.value);
        for (let i = 0; i < k; i++) {
          datasets.push({
            label: `Grupo ${i + 1}`,
            data: data.filter((_, idx) => assignments[idx] === i),
            backgroundColor: colors[i % colors.length] + "80",
            type: "scatter",
          });
        }
      } else {
        datasets.push({
          label: "Gente en el Boliche",
          data: data,
          backgroundColor: "rgba(255, 255, 255, 0.4)",
          type: "scatter",
        });
      }
      clusteringChart = new Chart(clusteringChartCtx, {
        data: { datasets },
        options: {
          ...mlChartOptions,
          scales: {
            ...mlChartOptions.scales,
            x: {
              ...mlChartOptions.scales.x,
              title: { display: true, text: "Caracter√≠stica 1" },
            },
            y: {
              ...mlChartOptions.scales.y,
              title: { display: true, text: "Caracter√≠stica 2" },
            },
          },
        },
      });
    }

    clusterBtn.addEventListener("click", () => {
      const k = parseInt(clustersSlider.value);
      const assignments = kMeans(clusterData, k);
      drawClusteringChart(clusterData, assignments);
    });

    clustersSlider.addEventListener("input", (e) => {
      clustersValue.textContent = e.target.value;
      drawClusteringChart(clusterData);
    });

    // --- DIMENSIONALITY REDUCTION ---
    const pcaChartCtx = document.getElementById("pcaChart").getContext("2d");
    const tsneChartCtx = document.getElementById("tsneChart").getContext("2d");
    const dimRedBtn = document.getElementById("dimRedBtn");
    let pcaChart, tsneChart;

    function generatePCADataset() {
      const data = [];
      for (let i = 0; i < 100; i++) {
        const r1 = Math.random() * 10 - 5;
        const r2 = (Math.random() - 0.5) * 2;
        const x = 0.866 * r1 - 0.5 * r2;
        const y = 0.5 * r1 + 0.866 * r2;
        data.push({ x: x + 5, y: y + 5 });
      }
      return data;
    }

    function simulateTSNE(data, k) {
      const assignments = kMeans(data, k);
      const separatedCentroids = Array.from({ length: k }, (_, i) => ({
        x: 2 + (i % 3) * 3,
        y: 8 - Math.floor(i / 3) * 3,
      }));
      return data.map((point, i) => {
        const clusterId = assignments[i];
        const centroid =
          separatedCentroids[clusterId % separatedCentroids.length];
        return {
          x: centroid.x + (Math.random() - 0.5) * 2,
          y: centroid.y + (Math.random() - 0.5) * 2,
        };
      });
    }

    function drawPCATsneCharts() {
      if (pcaChart) pcaChart.destroy();
      if (tsneChart) tsneChart.destroy();

      const pcaData = generatePCADataset();
      const tsneOriginalData = generateClusterData(150, 3);
      const tsneResult = simulateTSNE(tsneOriginalData, 3);

      pcaChart = new Chart(pcaChartCtx, {
        type: "scatter",
        data: {
          datasets: [
            {
              label: "Datos Originales",
              data: pcaData,
              backgroundColor: "rgba(255, 255, 255, 0.4)",
            },
            {
              label: "Componente Principal 1",
              data: [
                { x: 0, y: 2.5 },
                { x: 10, y: 7.5 },
              ],
              type: "line",
              borderColor: colors[0],
              borderWidth: 3,
              pointRadius: 0,
            },
            {
              label: "Componente Principal 2",
              data: [
                { x: 3, y: 8 },
                { x: 7, y: 2 },
              ],
              type: "line",
              borderColor: colors[1],
              borderWidth: 2,
              pointRadius: 0,
              borderDash: [5, 5],
            },
          ],
        },
        options: {
          ...mlChartOptions,
          scales: {
            ...mlChartOptions.scales,
            x: {
              ...mlChartOptions.scales.x,
              title: { display: true, text: "Variable Original 1" },
            },
            y: {
              ...mlChartOptions.scales.y,
              title: { display: true, text: "Variable Original 2" },
            },
          },
        },
      });

      const assignments = kMeans(tsneOriginalData, 3);
      tsneChart = new Chart(tsneChartCtx, {
        type: "scatter",
        data: {
          datasets: [
            {
              label: "Grupo 1",
              data: tsneResult.filter((_, i) => assignments[i] === 0),
              backgroundColor: colors[0],
            },
            {
              label: "Grupo 2",
              data: tsneResult.filter((_, i) => assignments[i] === 1),
              backgroundColor: colors[1],
            },
            {
              label: "Grupo 3",
              data: tsneResult.filter((_, i) => assignments[i] === 2),
              backgroundColor: colors[2],
            },
          ],
        },
        options: {
          ...mlChartOptions,
          scales: {
            ...mlChartOptions.scales,
            x: {
              ...mlChartOptions.scales.x,
              title: { display: true, text: "Dimensi√≥n Reducida 1" },
            },
            y: {
              ...mlChartOptions.scales.y,
              title: { display: true, text: "Dimensi√≥n Reducida 2" },
            },
          },
        },
      });
    }

    dimRedBtn.addEventListener("click", drawPCATsneCharts);

    // --- GEMINI API LOGIC ---
    const geminiModal = document.getElementById("gemini-modal");
    const closeModalBtn = document.getElementById("close-modal-btn");
    const geminiResponseEl = document.getElementById("gemini-response");
    const geminiLoader = document.getElementById("gemini-loader");
    const modalTitle = document.getElementById("modal-title");
    const apiKeyInput = document.getElementById("gemini-api-key-input");
    let currentModel = "";

    document.querySelectorAll(".gemini-btn").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        currentModel = e.target.dataset.model;
        modalTitle.textContent = `Explicaci√≥n de ${currentModel}`;
        geminiResponseEl.innerHTML = "Seleccion√° un estilo de explicaci√≥n...";
        geminiModal.classList.remove("hidden");
      });
    });

    closeModalBtn.addEventListener("click", () => {
      geminiModal.classList.add("hidden");
    });

    document.querySelectorAll(".prompt-btn").forEach((btn) => {
      btn.addEventListener("click", async (e) => {
        const style = e.target.dataset.style;
        await callGemini(currentModel, style);
      });
    });

    async function callGemini(modelName, style) {
      const apiKey = apiKeyInput.value.trim() || "";
      if (!apiKey) {
        geminiResponseEl.innerHTML =
          '<span class="text-red-400">¬°Che, campe√≥n! Necesit√°s poner tu clave de API de Gemini para que esto funcione.</span>';
        apiKeyInput.focus();
        apiKeyInput.classList.add("border-red-500");
        return;
      }
      apiKeyInput.classList.remove("border-red-500");

      geminiLoader.classList.remove("hidden");
      geminiResponseEl.innerHTML = "";

      const prompts = {
        simple: `Explica qu√© es y para qu√© sirve el modelo de ${modelName} como si se lo contaras a un amigo en un bar. Usa un lenguaje simple, directo y con tonada argentina.`,
        analogy: `Explica el modelo de ${modelName} usando una analog√≠a creativa y f√°cil de entender para alguien que no sabe nada de machine learning, con un toque de humor argentino.`,
        business: `Explica c√≥mo una empresa podr√≠a usar el modelo de ${modelName} para segmentar clientes o encontrar anomal√≠as. Dame un caso de uso pr√°ctico y concreto, bien argento.`,
      };

      const userQuery = prompts[style];
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
      const payload = { contents: [{ parts: [{ text: userQuery }] }] };

      try {
        const response = await fetch(apiUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!response.ok)
          throw new Error(`Error de la API: ${response.status}`);
        const result = await response.json();
        const text = result.candidates[0].content.parts[0].text;
        geminiResponseEl.innerHTML = text
          .replace(
            /\*\*(.*?)\*\*/g,
            '<strong class="text-orange-400">$1</strong>'
          )
          .replace(/\n/g, "<br>");
      } catch (error) {
        console.error("Error llamando a Gemini:", error);
        geminiResponseEl.innerHTML =
          '<span class="text-red-400">Hubo un problema al conectar con la IA. Verific√° tu clave de API y la consola.</span>';
      } finally {
        geminiLoader.classList.add("hidden");
      }
    }


    // --- Carga inicial ---
    window.addEventListener("load", () => {
      // Cargas de modelos no supervisados
      clusterData = generateClusterData(150, 5);
      drawClusteringChart(clusterData);
      clustersValue.textContent = clustersSlider.value;
      drawPCATsneCharts();

      if (window.MathJax) {
        MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
      }
    });
  </script>
</body>

</html>